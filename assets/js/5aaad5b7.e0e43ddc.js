"use strict";(self.webpackChunkrushjs_io=self.webpackChunkrushjs_io||[]).push([[5584],{5242:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var s=t(3929);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);n&&(s=s.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,s)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,s,o=function(e,n){if(null==e)return{};var t,s,o={},r=Object.keys(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)t=r[s],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=s.createContext({}),h=function(e){var n=s.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},c=function(e){var n=h(e.components);return s.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return s.createElement(s.Fragment,{},n)}},p=s.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=h(t),d=o,m=p["".concat(l,".").concat(d)]||p[d]||u[d]||r;return t?s.createElement(m,a(a({ref:n},c),{},{components:t})):s.createElement(m,a({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=p;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var h=2;h<r;h++)a[h]=t[h];return s.createElement.apply(null,a)}return s.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6453:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>h,toc:()=>u});var s=t(394),o=t(1614),r=(t(3929),t(5242)),a=["components"],i={title:"rush.json"},l=void 0,h={unversionedId:"pages/configs/rush_json",id:"pages/configs/rush_json",title:"rush.json",description:"This is the template that rush init",source:"@site/docs/pages/configs/rush_json.md",sourceDirName:"pages/configs",slug:"/pages/configs/rush_json",permalink:"/pages/configs/rush_json",editUrl:"https://github.com/microsoft/rushstack-websites/tree/main/websites/rushjs.io/docs/pages/configs/rush_json.md",tags:[],version:"current",frontMatter:{title:"rush.json"},sidebar:"docsSidebar",previous:{title:"experiments.json",permalink:"/pages/configs/experiments_json"},next:{title:"rush-project.json (experimental)",permalink:"/pages/configs/rush-project_json"}},c={},u=[],p={toc:u};function d(e){var n=e.components,t=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,s.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is the template that ",(0,r.kt)("a",{parentName:"p",href:"../../commands/rush_init"},"rush init"),"\ngenerates for ",(0,r.kt)("strong",{parentName:"p"},"rush.json")," (in the repo root folder):"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"<","repo root",">","rush.json")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'/**\n * This is the main configuration file for Rush.\n * For full documentation, please see https://rushjs.io\n */\n{\n  "$schema": "https://developer.microsoft.com/json-schemas/rush/v5/rush.schema.json",\n\n  /**\n   * (Required) This specifies the version of the Rush engine to be used in this repo.\n   * Rush\'s "version selector" feature ensures that the globally installed tool will\n   * behave like this release, regardless of which version is installed globally.\n   *\n   * The common/scripts/install-run-rush.js automation script also uses this version.\n   *\n   * NOTE: If you upgrade to a new major version of Rush, you should replace the "v5"\n   * path segment in the "$schema" field for all your Rush config files.  This will ensure\n   * correct error-underlining and tab-completion for editors such as VS Code.\n   */\n  "rushVersion": "5.40.0",\n\n  /**\n   * The next field selects which package manager should be installed and determines its version.\n   * Rush installs its own local copy of the package manager to ensure that your build process\n   * is fully isolated from whatever tools are present in the local environment.\n   *\n   * Specify one of: "pnpmVersion", "npmVersion", or "yarnVersion".  See the Rush documentation\n   * for details about these alternatives.\n   */\n  "pnpmVersion": "5.15.2",\n\n  // "npmVersion": "4.5.0",\n  // "yarnVersion": "1.9.4",\n\n  /**\n   * Options that are only used when the PNPM package manager is selected\n   */\n  "pnpmOptions": {\n    /**\n     * Specifies the location of the PNPM store.  There are two possible values:\n     *\n     * - "local" - use the "pnpm-store" folder in the current configured temp folder:\n     *   "common/temp/pnpm-store" by default.\n     * - "global" - use PNPM\'s global store, which has the benefit of being shared\n     *    across multiple repo folders, but the disadvantage of less isolation for builds\n     *    (e.g. bugs or incompatibilities when two repos use different releases of PNPM)\n     *\n     * RUSH_PNPM_STORE_PATH will override the directory that will be used as the store\n     *\n     * In all cases, the store path will be overridden by the environment variable RUSH_PNPM_STORE_PATH.\n     *\n     * The default value is "local".\n     */\n    // "pnpmStore": "local",\n\n    /**\n     * If true, then Rush will add the "--strict-peer-dependencies" option when invoking PNPM.\n     * This causes "rush install" to fail if there are unsatisfied peer dependencies, which is\n     * an invalid state that can cause build failures or incompatible dependency versions.\n     * (For historical reasons, JavaScript package managers generally do not treat this invalid\n     * state as an error.)\n     *\n     * The default value is false to avoid legacy compatibility issues.\n     * It is strongly recommended to set strictPeerDependencies=true.\n     */\n    // "strictPeerDependencies": true,\n\n    /**\n     * Configures the strategy used to select versions during installation.\n     *\n     * This feature requires PNPM version 3.1 or newer.  It corresponds to the "--resolution-strategy" command-line\n     * option for PNPM.  Possible values are "fast" and "fewer-dependencies".  PNPM\'s default is "fast", but this may\n     * be incompatible with certain packages, for example the "@types" packages from DefinitelyTyped.  Rush\'s default\n     * is "fewer-dependencies", which causes PNPM to avoid installing a newer version if an already installed version\n     * can be reused; this is more similar to NPM\'s algorithm.\n     *\n     * After modifying this field, it\'s recommended to run "rush update --full" so that the package manager\n     * will recalculate all version selections.\n     */\n    // "resolutionStrategy": "fast",\n\n    /**\n     * If true, then `rush install` will report an error if manual modifications\n     * were made to the PNPM shrinkwrap file without running "rush update" afterwards.\n     *\n     * This feature protects against accidental inconsistencies that may be introduced\n     * if the PNPM shrinkwrap file ("pnpm-lock.yaml") is manually edited.  When this\n     * feature is enabled, "rush update" will append a hash to the file as a YAML comment,\n     * and then "rush update" and "rush install" will validate the hash.  Note that this does not prohibit\n     * manual modifications, but merely requires "rush update" be run\n     * afterwards, ensuring that PNPM can report or repair any potential inconsistencies.\n     *\n     * To temporarily disable this validation when invoking "rush install", use the\n     * "--bypass-policy" command-line parameter.\n     *\n     * The default value is false.\n     */\n    // "preventManualShrinkwrapChanges": true,\n\n    /**\n     * If true, then `rush install` will use the PNPM workspaces feature to perform the\n     * install.\n     *\n     * This feature uses PNPM to perform the entire monorepo install. When using workspaces, Rush will\n     * generate a "pnpm-workspace.yaml" file referencing all local projects to install. Rush will\n     * also generate a "pnpmfile.js" which is used to provide preferred versions support. When install\n     * is run, this pnpmfile will be used to replace dependency version ranges with a smaller subset\n     * of the original range. If the preferred version is not fully a subset of the original version\n     * range, it will be left as-is. After this, the pnpmfile.js provided in the repository (if one\n     * exists) will be called to further modify package dependencies.\n     *\n     * This option is experimental. The default value is false.\n     */\n    // "useWorkspaces": true\n  },\n\n  /**\n   * Older releases of the Node.js engine may be missing features required by your system.\n   * Other releases may have bugs.  In particular, the "latest" version will not be a\n   * Long Term Support (LTS) version and is likely to have regressions.\n   *\n   * Specify a SemVer range to ensure developers use a Node.js version that is appropriate\n   * for your repo.\n   *\n   * LTS schedule: https://nodejs.org/en/about/releases/\n   * LTS versions: https://nodejs.org/en/download/releases/\n   */\n  "nodeSupportedVersionRange": ">=12.13.0 <13.0.0 || >=14.15.0 <15.0.0",\n\n  /**\n   * Odd-numbered major versions of Node.js are experimental.  Even-numbered releases\n   * spend six months in a stabilization period before the first Long Term Support (LTS) version.\n   * For example, 8.9.0 was the first LTS version of Node.js 8.  Pre-LTS versions are not recommended\n   * for production usage because they frequently have bugs.  They may cause Rush itself\n   * to malfunction.\n   *\n   * Rush normally prints a warning if it detects a pre-LTS Node.js version.  If you are testing\n   * pre-LTS versions in preparation for supporting the first LTS version, you can use this setting\n   * to disable Rush\'s warning.\n   */\n  // "suppressNodeLtsWarning": false,\n\n  /**\n   * If you would like the version specifiers for your dependencies to be consistent, then\n   * uncomment this line. This is effectively similar to running "rush check" before any\n   * of the following commands:\n   *\n   *   rush install, rush update, rush link, rush version, rush publish\n   *\n   * In some cases you may want this turned on, but need to allow certain packages to use a different\n   * version. In those cases, you will need to add an entry to the "allowedAlternativeVersions"\n   * section of the common-versions.json.\n   */\n  // "ensureConsistentVersions": true,\n\n  /**\n   * Large monorepos can become intimidating for newcomers if project folder paths don\'t follow\n   * a consistent and recognizable pattern.  When the system allows nested folder trees,\n   * we\'ve found that teams will often use subfolders to create islands that isolate\n   * their work from others ("shipping the org").  This hinders collaboration and code sharing.\n   *\n   * The Rush developers recommend a "category folder" model, where buildable project folders\n   * must always be exactly two levels below the repo root.  The parent folder acts as the category.\n   * This provides a basic facility for grouping related projects (e.g. "apps", "libraries",\n   * "tools", "prototypes") while still encouraging teams to organize their projects into\n   * a unified taxonomy.  Limiting to 2 levels seems very restrictive at first, but if you have\n   * 20 categories and 20 projects in each category, this scheme can easily accommodate hundreds\n   * of projects.  In practice, you will find that the folder hierarchy needs to be rebalanced\n   * occasionally, but if that\'s painful, it\'s a warning sign that your development style may\n   * discourage refactoring.  Reorganizing the categories should be an enlightening discussion\n   * that brings people together, and maybe also identifies poor coding practices (e.g. file\n   * references that reach into other project\'s folders without using Node.js module resolution).\n   *\n   * The defaults are projectFolderMinDepth=1 and projectFolderMaxDepth=2.\n   *\n   * To remove these restrictions, you could set projectFolderMinDepth=1\n   * and set projectFolderMaxDepth to a large number.\n   */\n  // "projectFolderMinDepth": 2,\n  // "projectFolderMaxDepth": 2,\n\n  /**\n   * Today the npmjs.com registry enforces fairly strict naming rules for packages, but in the early\n   * days there was no standard and hardly any enforcement.  A few large legacy projects are still using\n   * nonstandard package names, and private registries sometimes allow it.  Set "allowMostlyStandardPackageNames"\n   * to true to relax Rush\'s enforcement of package names.  This allows upper case letters and in the future may\n   * relax other rules, however we want to minimize these exceptions.  Many popular tools use certain punctuation\n   * characters as delimiters, based on the assumption that they will never appear in a package name; thus if we relax\n   * the rules too much it is likely to cause very confusing malfunctions.\n   *\n   * The default value is false.\n   */\n  // "allowMostlyStandardPackageNames": true,\n\n  /**\n   * This feature helps you to review and approve new packages before they are introduced\n   * to your monorepo.  For example, you may be concerned about licensing, code quality,\n   * performance, or simply accumulating too many libraries with overlapping functionality.\n   * The approvals are tracked in two config files "browser-approved-packages.json"\n   * and "nonbrowser-approved-packages.json".  See the Rush documentation for details.\n   */\n  // "approvedPackagesPolicy": {\n  //   /**\n  //    * The review categories allow you to say for example "This library is approved for usage\n  //    * in prototypes, but not in production code."\n  //    *\n  //    * Each project can be associated with one review category, by assigning the "reviewCategory" field\n  //    * in the "projects" section of rush.json.  The approval is then recorded in the files\n  //    * "common/config/rush/browser-approved-packages.json" and "nonbrowser-approved-packages.json"\n  //    * which are automatically generated during "rush update".\n  //    *\n  //    * Designate categories with whatever granularity is appropriate for your review process,\n  //    * or you could just have a single category called "default".\n  //    */\n  //   "reviewCategories": [\n  //     // Some example categories:\n  //     "production", // projects that ship to production\n  //     "tools",      // non-shipping projects that are part of the developer toolchain\n  //     "prototypes"  // experiments that should mostly be ignored by the review process\n  //   ],\n  //\n  //   /**\n  //    * A list of NPM package scopes that will be excluded from review.\n  //    * We recommend to exclude TypeScript typings (the "@types" scope), because\n  //    * if the underlying package was already approved, this would imply that the typings\n  //    * are also approved.\n  //    */\n  //   // "ignoredNpmScopes": ["@types"]\n  // },\n\n  /**\n   * If you use Git as your version control system, this section has some additional\n   * optional features you can use.\n   */\n  "gitPolicy": {\n    /**\n     * Work at a big company?  Tired of finding Git commits at work with unprofessional Git\n     * emails such as "beer-lover@my-college.edu"?  Rush can validate people\'s Git email address\n     * before they get started.\n     *\n     * Define a list of regular expressions describing allowable e-mail patterns for Git commits.\n     * They are case-insensitive anchored JavaScript RegExps.  Example: ".*@example\\.com"\n     *\n     * IMPORTANT: Because these are regular expressions encoded as JSON string literals,\n     * RegExp escapes need two backslashes, and ordinary periods should be "\\\\.".\n     */\n    // "allowedEmailRegExps": [\n    //   "[^@]+@users\\\\.noreply\\\\.github\\\\.com",\n    //   "travis@example\\\\.org"\n    // ],\n\n    /**\n     * When Rush reports that the address is malformed, the notice can include an example\n     * of a recommended email.  Make sure it conforms to one of the allowedEmailRegExps\n     * expressions.\n     */\n    // "sampleEmail": "mrexample@users.noreply.github.com",\n\n    /**\n     * The commit message to use when committing changes during \'rush publish\'.\n     *\n     * For example, if you want to prevent these commits from triggering a CI build,\n     * you might configure your system\'s trigger to look for a special string such as "[skip-ci]"\n     * in the commit message, and then customize Rush\'s message to contain that string.\n     */\n    // "versionBumpCommitMessage": "Applying package updates. [skip-ci]",\n\n    /**\n     * The commit message to use when committing changes during \'rush version\'.\n     *\n     * For example, if you want to prevent these commits from triggering a CI build,\n     * you might configure your system\'s trigger to look for a special string such as "[skip-ci]"\n     * in the commit message, and then customize Rush\'s message to contain that string.\n     */\n    // "changeLogUpdateCommitMessage": "Applying package updates. [skip-ci]"\n  },\n\n  "repository": {\n    /**\n     * The URL of this Git repository, used by "rush change" to determine the base branch for your PR.\n     *\n     * The "rush change" command needs to determine which files are affected by your PR diff.\n     * If you merged or cherry-picked commits from the main branch into your PR branch, those commits\n     * should be excluded from this diff (since they belong to some other PR).  In order to do that,\n     * Rush needs to know where to find the base branch for your PR.  This information cannot be\n     * determined from Git alone, since the "pull request" feature is not a Git concept.  Ideally\n     * Rush would use a vendor-specific protocol to query the information from GitHub, Azure DevOps, etc.\n     * But to keep things simple, "rush change" simply assumes that your PR is against the "main" branch\n     * of the Git remote indicated by the repository.url setting in rush.json.  If you are working in\n     * a GitHub "fork" of the real repo, this setting will be different from the repository URL of your\n     * your PR branch, and in this situation "rush change" will also automatically invoke "git fetch"\n     * to retrieve the latest activity for the remote main branch.\n     */\n    // "url": "https://github.com/microsoft/rush-example",\n\n    /**\n     * The default branch name. This tells "rush change" which remote branch to compare against.\n     * The default value is "main"\n     */\n    // "defaultBranch": "main",\n\n    /**\n     * The default remote. This tells "rush change" which remote to compare against if the remote URL is\n     * not set or if a remote matching the provided remote URL is not found.\n     */\n    // "defaultRemote": "origin"\n  },\n\n  /**\n   * Event hooks are customized script actions that Rush executes when specific events occur\n   */\n  "eventHooks": {\n    /**\n     * The list of shell commands to run before the Rush installation starts\n     */\n    "preRushInstall": [\n      // "common/scripts/pre-rush-install.js"\n    ],\n\n    /**\n     * The list of shell commands to run after the Rush installation finishes\n     */\n    "postRushInstall": [],\n\n    /**\n     * The list of shell commands to run before the Rush build command starts\n     */\n    "preRushBuild": [],\n\n    /**\n     * The list of shell commands to run after the Rush build command finishes\n     */\n    "postRushBuild": []\n  },\n\n  /**\n   * Installation variants allow you to maintain a parallel set of configuration files that can be\n   * used to build the entire monorepo with an alternate set of dependencies.  For example, suppose\n   * you upgrade all your projects to use a new release of an important framework, but during a transition period\n   * you intend to maintain compatibility with the old release.  In this situation, you probably want your\n   * CI validation to build the entire repo twice: once with the old release, and once with the new release.\n   *\n   * Rush "installation variants" correspond to sets of config files located under this folder:\n   *\n   *   common/config/rush/variants/<variant_name>\n   *\n   * The variant folder can contain an alternate common-versions.json file.  Its "preferredVersions" field can be used\n   * to select older versions of dependencies (within a loose SemVer range specified in your package.json files).\n   * To install a variant, run "rush install --variant <variant_name>".\n   *\n   * For more details and instructions, see this article:  https://rushjs.io/pages/advanced/installation_variants/\n   */\n  "variants": [\n    // {\n    //   /**\n    //    * The folder name for this variant.\n    //    */\n    //   "variantName": "old-sdk",\n    //\n    //   /**\n    //    * An informative description\n    //    */\n    //   "description": "Build this repo using the previous release of the SDK"\n    // }\n  ],\n\n  /**\n   * Rush can collect anonymous telemetry about everyday developer activity such as\n   * success/failure of installs, builds, and other operations.  You can use this to identify\n   * problems with your toolchain or Rush itself.  THIS TELEMETRY IS NOT SHARED WITH MICROSOFT.\n   * It is written into JSON files in the common/temp folder.  It\'s up to you to write scripts\n   * that read these JSON files and do something with them.  These scripts are typically registered\n   * in the "eventHooks" section.\n   */\n  // "telemetryEnabled": false,\n\n  /**\n   * Allows creation of hotfix changes. This feature is experimental so it is disabled by default.\n   * If this is set, \'rush change\' only allows a \'hotfix\' change type to be specified. This change type\n   * will be used when publishing subsequent changes from the monorepo.\n   */\n  // "hotfixChangeEnabled": false,\n\n  /**\n   * (Required) This is the inventory of projects to be managed by Rush.\n   *\n   * Rush does not automatically scan for projects using wildcards, for a few reasons:\n   * 1. Depth-first scans are expensive, particularly when tools need to repeatedly collect the list.\n   * 2. On a caching CI machine, scans can accidentally pick up files left behind from a previous build.\n   * 3. It\'s useful to have a centralized inventory of all projects and their important metadata.\n   */\n  "projects": [\n    // {\n    //   /**\n    //    * The NPM package name of the project (must match package.json)\n    //    */\n    //   "packageName": "my-app",\n    //\n    //   /**\n    //    * The path to the project folder, relative to the rush.json config file.\n    //    */\n    //   "projectFolder": "apps/my-app",\n    //\n    //   /**\n    //    * An optional category for usage in the "browser-approved-packages.json"\n    //    * and "nonbrowser-approved-packages.json" files.  The value must be one of the\n    //    * strings from the "reviewCategories" defined above.\n    //    */\n    //   "reviewCategory": "production",\n    //\n    //   /**\n    //    * A list of local projects that appear as devDependencies for this project, but cannot be\n    //    * locally linked because it would create a cyclic dependency; instead, the last published\n    //    * version will be installed in the Common folder.\n    //    */\n    //   "cyclicDependencyProjects": [\n    //     // "my-toolchain"\n    //   ],\n    //\n    //   /**\n    //    * If true, then this project will be ignored by the "rush check" command.\n    //    * The default value is false.\n    //    */\n    //   // "skipRushCheck": false,\n    //\n    //   /**\n    //    * A flag indicating that changes to this project will be published to npm, which affects\n    //    * the Rush change and publish workflows. The default value is false.\n    //    * NOTE: "versionPolicyName" and "shouldPublish" are alternatives; you cannot specify them both.\n    //    */\n    //   // "shouldPublish": false,\n    //\n    //   /**\n    //    * Facilitates postprocessing of a project\'s files prior to publishing.\n    //    *\n    //    * If specified, the "publishFolder" is the relative path to a subfolder of the project folder.\n    //    * The "rush publish" command will publish the subfolder instead of the project folder.  The subfolder\n    //    * must contain its own package.json file, which is typically a build output.\n    //    */\n    //   // "publishFolder": "temp/publish",\n    //\n    //   /**\n    //    * An optional version policy associated with the project.  Version policies are defined\n    //    * in "version-policies.json" file.  See the "rush publish" documentation for more info.\n    //    * NOTE: "versionPolicyName" and "shouldPublish" are alternatives; you cannot specify them both.\n    //    */\n    //   // "versionPolicyName": ""\n    // },\n    //\n    // {\n    //   "packageName": "my-controls",\n    //   "projectFolder": "libraries/my-controls",\n    //   "reviewCategory": "production"\n    // },\n    //\n    // {\n    //   "packageName": "my-toolchain",\n    //   "projectFolder": "tools/my-toolchain",\n    //   "reviewCategory": "tools"\n    // }\n  ]\n}\n')))}d.isMDXComponent=!0}}]);